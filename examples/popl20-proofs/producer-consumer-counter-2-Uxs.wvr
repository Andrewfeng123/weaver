; -s yices-smtinterpol -m partition-progress-context --semi -b rr
(var queue (Int) Int)
(var front back Int)
(var d w W temp Int)
(var assert Bool)
(use
assert
false
true
(<= back front)
(<= back (+ front 1))
(<= d W)
(<= d (+ W (- 1)))
(<= d (+ W (- 2)))
(<= front (+ back (- 1)))
(<= w W)
(<= w 0)
(<= 0 W)
(<= (+ w d) W)
(= (+ back (- front)) 0)
(= (+ front (- back)) 0)
(=> (not assert) (<= (+ W (- d) 1) 0))
(=> (not (<= (+ W (- d) 1) 0)) assert)
(and assert (not (<= w 0)))
(and (<= back (+ front 1)) (<= front (+ back (- 1))) (<= d (+ W (- 2))) (= 1 (queue front)))
(and (<= back (+ front 1)) (<= front (+ back (- 1))) (<= (+ w d) W) (= 1 (queue front)))
(and (<= back (+ front 1)) (<= front (+ back (- 1))) (<= (+ w d) (+ W (- 1))) (= 1 (queue front)))
(and (<= back (+ (+ front 1) 1)) (<= (+ front 1) (+ back (- 1))) (<= d (+ W (- 3))) (= 1 (queue (+ front 1))) (= 1 (queue front)))
(and (<= back (+ (+ front 1) 1)) (<= (+ front 1) (+ back (- 1))) (<= (+ d w) (+ W (- 2))) (= 1 (queue (+ front 1))) (= 1 (queue front)))
(and (<= back (+ (+ front 1) 1)) (<= (+ front 1) (+ back (- 1))) (<= (+ w d) (+ W (- 1))) (= 1 (queue (+ front 1))) (= 1 (queue front)))
(and (<= d (+ W (- 1))) (= back front))
(and (<= d (+ W (- 1))) (= 1 (queue front)))
(and (<= d (+ W (- 2))) (= 1 (queue front)))
(and (<= d (+ W (- 3))) (= 1 (queue front)))
(and (<= d (+ W (- 3))) (= 1 (queue (+ front 1))) (= 1 (queue front)))
(and (<= w W) (<= 0 W))
(and (<= (+ d w) (+ W (- 2))) (= 1 (queue front)))
(and (<= (+ d w) (+ W (- 2))) (= 1 (queue front)) (<= d W))
(and (<= (+ d w) (+ W (- 2))) (= 1 (queue (+ front 1))) (= 1 (queue front)))
(and (<= (+ temp (- 1)) 0) (<= d (+ W (- 1))))
(and (<= (+ w d) W) (<= d W))
(and (<= (+ w d) W) (<= d W) (= back front))
(and (<= (+ w d) W) (<= front (+ back (- 1))) (<= back (+ front 1)) (= 1 (queue front)))
(and (<= (+ w d) W) (= back front))
(and (<= (+ w d) W) (= back front) (<= d W))
(and (<= (+ w d) W) (= 1 (queue front)))
(and (<= (+ w d) W) (= 1 (queue front)) (<= d W))
(and (<= (+ w d) (+ W (- 1))) (<= front (+ back (- 1))) (<= back (+ front 1)) (= 1 (queue front)))
(and (<= (+ w d) (+ W (- 1))) (= 1 (queue front)))
(and (<= (+ w d) (+ W (- 1))) (= 1 (queue front)) (<= d W))
(and (<= (+ w d) (+ W (- 1))) (= 1 (queue (+ front 1))) (= 1 (queue front)))
(and (= 1 (queue front)) (<= d (+ W (- 1))))
(and (= 1 (queue front)) (= (+ temp (- 1)) 0) (<= d (+ W (- 2))))
(and (= 1 (queue (+ front 1))) (<= d (+ W (- 2))) (= 1 (queue front)))
(and (= 1 (queue (+ (+ front 1) 1))) (<= d (+ W (- 3))) (= 1 (queue (+ front 1))) (= 1 (queue front)))
(and (= (+ back (- front)) 0) (<= d (+ W (- 1))))
(and (= (+ back (- front)) 0) (<= (+ w d) W))
(and (= (+ back (- front)) 0) (= (+ temp (- 1)) 0) (<= (+ w d) W))
(and (= (+ back (- front)) 0) (= (+ temp (- 1)) 0) (<= (+ w d) (+ W (- 1))))
(and (= (+ temp (- 1)) 0) (<= d (+ W (- 1))))
(and (= (+ temp (- 1)) 0) (<= d (+ W (- 2))))
(and (= (+ temp (- 1)) 0) (<= d (+ W (- 3))))
(and (= (+ temp (- 1)) 0) (<= (+ w d) W))
(and (= (+ temp (- 1)) 0) (<= (+ w d) (+ W (- 1))))
(and (= (+ temp (- 1)) 0) (and (<= d (+ W (- 3))) (= 1 (queue front))))
(and (= (+ temp (- 1)) 0) (and (= 1 (queue front)) (<= d (+ W (- 2)))))
(and (= (+ temp (- 1)) 0) (and (= 1 (queue (+ front 1))) (<= d (+ W (- 3))) (= 1 (queue front))))
(and (not (<= w 0)) assert)
(and (not (<= (+ W (- d) 1) 0)) assert)
)

(assume (>= W 0))
(assume (= w W))
(assume (= d 0))
(assume assert)
(assume (= front back))

(par
  (while (and assert (< 0 w))
    (atomic
      (assume (= (queue back) 1))
      (set! back (+ back 1)))
    (set! w (- w 1)))
  (while assert
    (atomic
      (assume (< front back))
      (set! temp (queue front))
      (set! front (+ front 1)))
    (set! d (+ d temp)))
  (set! assert (<= d W)))

(assume (not assert))
